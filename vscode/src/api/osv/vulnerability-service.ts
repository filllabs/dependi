import NodeCache from "node-cache";
import * as https from "https";
import {
  AllPackageVulnerabilityResult,
  PackageVersionVulnerabilities,
  PackageVulnerabilityQueries,
  PackageVulnerabilityResults,
  VulnerabilityResult,
  VulnerabilityQuery
} from "./interfaces";
import Dependency from "../../core/Dependency";
import { StatusBar } from "../../ui/status-bar";
import { Settings } from "../../config";

const cache = new NodeCache({ stdTTL: 60 * 10 });

export function fetchDataFromOSV(request: PackageVulnerabilityQueries): Promise<PackageVulnerabilityResults> {
  const options = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
  };

  return new Promise((resolve, reject) => {
    const req = https.request(Settings.vulnerability.osvBatch, options, (res) => {
      let data = "";

      res.on("data", (chunk) => {
        data += chunk;
      });

      res.on("end", () => {
        try {
          const responseData: AllPackageVulnerabilityResult = JSON.parse(data);

          for (let i = 0; i < responseData.results?.length; i++) {
            responseData.results[i].packageName = request.queries[i].package.name;
            responseData.results[i].version = request.queries[i].version!;
            if (responseData.results[i].vulns) {
              responseData.results[i].vulns = responseData.results[i].vulns.filter((vuln) => {
                if (!Settings.vulnerability.ghsa) {
                  return !vuln.id.startsWith("GHSA");
                } else {
                  return true;
                }
              });
            }
          }
          resolve(responseData);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on("error", (error) => {
      reject(error);
    });

    req.write(JSON.stringify(request));
    req.end();
  });
}

const queryOSVAPI = async (request: PackageVulnerabilityQueries): Promise<PackageVulnerabilityResults> => {
  try {
    const cacheKey = JSON.stringify({ request, ghsaCheck: Settings.vulnerability.ghsa });
    if (cache.has(cacheKey)) {
      const cachedResponse = cache.get<PackageVulnerabilityResults>(cacheKey);
      if (cachedResponse === undefined) {
        throw new Error("Cached response is undefined");
      }
      return cachedResponse;
    } else {
      const response = await fetchDataFromOSV(request);
      cache.set(cacheKey, response);
      return response;
    }
  } catch (error) {
    console.error("Error fetching data from OSV API:", error);
    throw error;
  }
};

export const queryMultiplePackageVulns = async (
  dependencies: Dependency[],
  environment: string
) => {
  try {
    const queryArray: PackageVulnerabilityQueries = {
      queries: []
    };
    for (let i = 0; i < dependencies.length; i++) {
      const packageName = dependencies[i].item.key;
      const currentVersionIndex = dependencies[i].versions?.findIndex((version) => version === dependencies[i]?.item?.value!) ?? (dependencies[i].versions?.length ?? 0) - 1;
      for (let j = 0; j <= currentVersionIndex; j++) {
        if (!dependencies[i].versions || !dependencies[i]?.versions?.[j]) {
          continue;
        }
        queryArray.queries.push({
          version: dependencies[i].versions?.[j],
          package: {
            name: packageName,
            ecosystem: environment
          }
        });
      }
    }
    StatusBar.setText("Info", "Fetching vulnerabilities from OSV");
    const response = await queryOSVAPI(queryArray);
    const packageWithVulnArray: Dependency[] = groupByPackages(response, dependencies);
    StatusBar.setText("Info", "Vulnerabilities fetched from OSV");
    return packageWithVulnArray;
  } catch (error) {
    console.error("Error querying multiple package vulnerabilities:", error);
    return [];
  }
};

function groupByPackages(response: PackageVulnerabilityResults, dependencies: Dependency[]) {
  const packagesMap = new Map<string, PackageVersionVulnerabilities>();
  for (let i = 0; i < response.results?.length; i++) {
    const key = response.results[i].packageName;
    if (packagesMap.has(key)) {
      const value = packagesMap.get(key);
      value?.versionVulnerabilities.push({
        version: response.results[i].version,
        vulnerabilities: response.results[i].vulns
      });
      packagesMap.set(key, value!);
    } else {
      packagesMap.set(key, {
        packageName: key,
        versionVulnerabilities: [{
          version: response.results[i].version,
          vulnerabilities: response.results[i].vulns
        }]
      });
    }
  }
  for (let i = 0; i < dependencies?.length; i++) {
    const vulnerabilities = packagesMap.get(dependencies[i].item.key);
    const vulnsMap = new Map<string, string[]>();
    if (vulnerabilities?.versionVulnerabilities) {
      for (let j = 0; j < vulnerabilities?.versionVulnerabilities.length!; j++) {
        const vulnerabilityArray = vulnerabilities?.versionVulnerabilities[j];
        const idArray: string[] = [];
        if (vulnerabilityArray?.vulnerabilities) {
          vulnerabilityArray?.vulnerabilities.forEach((v) => {
            idArray.push(v.id);
          });
        }
        vulnsMap.set(vulnerabilityArray.version, idArray);
      }
    }
    dependencies[i].vulns = vulnsMap;
  }
  return dependencies;
}

export function fetchSingleQueryFromOSV(request: VulnerabilityQuery): Promise<VulnerabilityResult> {
  const options = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
  };

  return new Promise((resolve, reject) => {
    const req = https.request(Settings.vulnerability.osvSingle, options, (res) => {
      let data = "";

      res.on("data", (chunk) => {
        data += chunk;
      });

      res.on("end", () => {
        try {
          const responseData: VulnerabilityResult = JSON.parse(data);
          if (responseData.vulns) {
            if (!Settings.vulnerability.ghsa) {
              // if response data vulnerability id starts with GHSA, remove the vulnerability
              responseData.vulns = responseData.vulns.filter((vuln) => !vuln.id.startsWith("GHSA"));
            }
          }
          responseData.packageName = request.package.name;
          responseData.version = request.version!;
          resolve(responseData);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on("error", (error) => {
      reject(error);
    });

    req.write(JSON.stringify(request));
    req.end();
  });
}

export function fetchMultipleQueriesVulnCount(requests: VulnerabilityQuery[]): Promise<number> {
  // Use querybatch endpoint to fetch multiple queries
  const options = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
  };

  return new Promise((resolve, reject) => {
    const req = https.request(Settings.vulnerability.osvBatch, options, (res) => {
      let data = "";

      res.on("data", (chunk) => {
        data += chunk;
      });

      res.on("end", () => {
        try {
          let count = 0;
          const responseData: PackageVulnerabilityResults = JSON.parse(data);
          responseData.results?.forEach((result) => {
            if (result.vulns) {
              result.vulns.forEach((vuln) => {
                if (!Settings.vulnerability.ghsa) {
                  if (!vuln.id.startsWith("GHSA")) {
                    count++;
                  }
                } else {
                  count++;
                }
              });
            }
          });
          resolve(count);
        } catch (error) {
          reject(error);
        }
      });
    });

    req.on("error", (error) => {
      reject(error);
    });

    req.write(JSON.stringify({ queries: requests }));
    req.end();
  });
}