import * as vscode from "vscode";
import { getReportPDF } from "../api/index/dependi-index-server/reports";
import { winHelper } from "../commands/report-generator/utils";
import { Logger } from "../extension";
import { WebviewPanel } from "./MainPanel";

export class VulnerabilityReportPanel extends WebviewPanel {
  fetchedHTML: string;

  constructor(
    panel: vscode.WebviewPanel,
    extensionUri: vscode.Uri,
    fetchedHTML: string
  ) {
    super(panel, extensionUri);
    this.fetchedHTML = fetchedHTML;
    this._panel.webview.html = this.getWebviewContent(fetchedHTML);
    this._setWebviewMessageListener(this._panel.webview);
  }

  public static render(extensionUri: vscode.Uri, fetchedHTML: string) {
    const panel = vscode.window.createWebviewPanel(
      "vulnerabilityReport",
      "Vulnerability Report",
      { viewColumn: vscode.ViewColumn.One, preserveFocus: true },
      {
        enableScripts: true,
        retainContextWhenHidden: true,
      }
    );
    return new VulnerabilityReportPanel(panel, extensionUri, fetchedHTML);
  }

  private _getVulnerabilityReportHtml(fetchedHTML: string): string {
    return fetchedHTML;
  }

  protected getWebviewContent(fetchedHTML: string): string {
    return this._getVulnerabilityReportHtml(fetchedHTML);
  }

  private async handleExportReport(): Promise<void> {
    const defaultFileName = this.getSaveText();
    const options: vscode.SaveDialogOptions = {
      saveLabel: "Save PDF",
      filters: { "PDF Files": ["pdf"] },
      defaultUri: vscode.Uri.file(defaultFileName),
    };

    const uri = await vscode.window.showSaveDialog(options);
    if (uri) {
      let html = this._getVulnerabilityReportHtml(this.fetchedHTML);
      html = this.addHideClassToExportButton(html);
      const htmlPDF = await getReportPDF(html);

      if (!htmlPDF || !htmlPDF.body || htmlPDF.body.size === 0) {
        vscode.window.showErrorMessage("Error exporting PDF.");
        return;
      }

      const htmlBuffer = await this.blobToUint8Array(htmlPDF.body);
      const uriPath = uri.path;
      const fixedUriPath = winHelper(uriPath);
      const fixedUri = vscode.Uri.file(fixedUriPath);

      await vscode.workspace.fs.writeFile(fixedUri, htmlBuffer);

      vscode.window
        .showInformationMessage(`Report saved to ${uri.fsPath}`, "Open File")
        .then(async (selection) => {
          if (selection === "Open File") {
            const fileUri = vscode.Uri.file(uri.fsPath);
            await vscode.env.openExternal(fileUri);
          }
        });
    }
  }

  private _setWebviewMessageListener(webview: vscode.Webview): void {
    webview.onDidReceiveMessage(
      async (message: any) => {
        if (message.command === "exportReport") {
          try {
            await this.handleExportReport();
          } catch (error) {
            console.error("Failed to save PDF: ", error);
            Logger.appendLine("Failed to save PDF: " + error);
            vscode.window.showErrorMessage("Error exporting PDF.");
          }
        }
      },
      undefined,
      this._disposables
    );
  }

  private getSaveText(): string {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const formattedHours = hours < 10 ? "0" + hours : hours;
    const formattedMinutes = minutes < 10 ? "0" + minutes : minutes;
    const currentDate = now.toISOString().split("T")[0];
    return `Vulnerability_Report-${currentDate}-${formattedHours}_${formattedMinutes}.pdf`;
  }

  private addHideClassToExportButton(html: string): string {
    return html.replace(
      '<button id="pdf-export-button">',
      '<button id="pdf-export-button" class="hide-in-pdf">'
    );
  }

  private async blobToUint8Array(blob: Blob): Promise<Uint8Array> {
    const arrayBuffer = await blob.arrayBuffer();
    return new Uint8Array(arrayBuffer);
  }
}
